---
title: "Phylogenetics and microbiomes in R"
author: |
  | Florent Mazel, U. of British Columbia
  | Jon Sanders, Cornell University
  | edited by Kim Dill-McFarland, U. of British Columbia
date: "version `r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: yes
    toc_float:
      collapsed: no
  pdf_document:
    toc: yes
    latex_engine: xelatex
urlcolor: blue
editor_options: 
  chunk_output_type: console
---
# Overview
Microorganisms are the most widespread form of life on Earth, inhabiting most ecosystems and driving the bulk of global biogeochemical cycles. Yet, we still know very little about the breadth or depth of diversity of these microbial communities. While recent technical advances, like next-generation sequencing, have started to unravel microbiome diversity patterns, many questions still remain. For example, what microbial unit should we use to study microbiome compositional patterns (*e.g.* beta-diversity)? Should we use operational taxonomic units (OTUs) or amplicon sequence variants (ASVs) to define microbial units? And at what similarity level do we define a 'species'?

In this workshop series, we tackle some of the reigning questions in the field of microbial ecology through phylogenetic analyses, thus avoiding *a priori* choices of microbial units. We will provide theoretical background and practical examples of such analysis using R.  

You will learn how to:

* build a phylogenetic tree with FastTree
* compare microbial community compositions using phylogenetics and beta-diversity
* statistically test beta-diversity for associations with metadata
* visualize phylogenetic trees and beta-diversity of microbial communities

This workshop assumes some prior experience with R (such as that in our [Introduction to R workshop](https://github.com/EDUCE-UBC/workshops_R/tree/master/intro_R_2hr)). It is also beneficial to have experience with the R tidyverse, such as that in our [workshop](https://github.com/EDUCE-UBC/workshops_R/tree/master/intro_tidyverse), and to have a basic working knowledge of Unix command line.

All code presented in this workshop is contained in the ["phylogenetics.R"](phylogenetics_main.R) R script file. You can follow along with the workshop by selecting the relevant line(s) of code and pressing ctrl+enter on Windows, cmd+enter on MacOS, or using the "Run" button in the upper right of your script window to execute it. There are also dedicated spaces in the R script for you to work on the given exercises which are indicated in the markdown with the RStudio logo ![](images/RStudio_logo.png){width=0.4in}.

Please call a TA if you have any problems with executing the code or if you need any help with the exercises. 

# Prior to the workshop
## Setup Instructions

Please come to the workshop with your laptop setup with the required
software and data files as described in our [setup instructions](setup/phylogenetics_setup.html).

## Background

Please read [Hallam SJ *et al*. 2017. Sci Data 4: 170158](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5663219/) "Monitoring microbial responses to ocean deoxygenation in a model oxygen minimum zone" to learn more about the data used in this workshop. You can also check out this [short video](https://youtu.be/XYQSm2Me86I) showing how the sampling was done!

# Data description
The data in this workshop were collected as part of an on-going oceanographic time series program in Saanich Inlet, a seasonally anoxic fjord on the East coast of Vancouver Island, British Columbia (Figure 1). 

<br>
<br>
![](images/Saanich.png){width=4in}
/ 

**Figure 1.** Map of Saanich Inlet indicating conventional sample collection stations (S1-S9). Data used in this workshop is sourced from S3.
<br>
<br>

Saanich Inlet is a steep sided fjord characterized by a shallow glacial sill located at the mouth of the inlet that restricts circulation in basin waters below 100 m (Figure 2).

<br>
<br>
![](images/Inlet_structure.png)
/ 

**Figure 2.** Structure of Saanich Inlet. The glacial sill restricts water circulation into and out of the lower depth of the inlet basin.
<br>
<br>

During spring and summer months, elevated primary production (like photosynthesis) in surface waters combined with restricted circulation results in progressive water column stratification and complete oxygen starvation (anoxia) in deep basin waters. In late summer, pulses of oxygenated nutrient-rich ocean waters up-welling from the Haro Straight cascade over the sill, displacing oxygen starved bottom waters upward. The intensity of these renewal events varies from year to year with implications for microbial ecology and biogeochemical cycles (Figure 3). 

<br>
<br>
![](images/oxygen_timeseries.png)
/ 

**Figure 3.** Contour plot of water column oxygen concentrations over multiple years in the time series. Warmer colors indicate high oxygen concentrations while cooler colors are low. Note the recurring pattern of oxygen decline below 100 m depth intervals followed by seasonal renewal events in late Summer into early Fall carrying more oxygenated waters into the Inlet. 
<br>
<br>

The seasonal cycle of stratification and deep water renewal enables spatial and temporal profiling across a wide range of water column energy states and nutrients, thus making Saanich Inlet a model ecosystem for studying microbial community responses to ocean deoxygenation. Ocean deoxygenation is a widespread phenomenon currently increasing due to climate change. 

While Saanich Inlet samples have been collected approximately monthly from 2006 to 2014, this workshop will focus on the microbial communities and associated geochemical data from a single time point (Cruise 72, August 2012) to keep the data size manageable. You can find details on the sequence data processing [here](https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/notes/mothur_pipeline.pdf) and information on the geochemical data processing in our [R tidyverse workshop](https://github.com/EDUCE-UBC/workshops_R/tree/master/intro_tidyverse).

For a brief introduction to the data used in this workshop series, see [Hallam SJ *et al*. 2017. Sci Data 4: 170158](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5663219/) "Monitoring microbial responses to ocean deoxygenation in a model oxygen minimum zone". More detailed information on the environmental context and time series data can be found in [Torres-BeltrÃ¡n M *et al*. 2017. Sci Data 4: 170159.](https://www.nature.com/articles/sdata2017159) "A compendium of geochemical information from the Saanich Inlet water column".

# Getting started
## Making an RStudio Project
Projects allow you to divide your work into self-contained contexts.

Let's create a project to work in.

In the top-right corner of your RStudio window, click the "Project: (None)" button to show the projects drop-down menu. Select "New Project..." > "New Directory" > "New Project." Under directory name, input "phylogenetics" and choose a parent directory to contain this project on your computer.

## Installing and loading packages

At the beginning of every R script, you should have a dedicated space for loading R packages. R packages allow any R user to code reproducible functions and share them with the R community. Packages exist for anything ranging from microbial ecology to complex graphics to multivariate modeling and beyond. 

In this workshop, we will use several packages listed below. Here, we load the necessary packages which *must already be installed* (see [setup instructions](setup/phylogenetics_setup.html) for details).

```{r, message=FALSE, warning=FALSE}
# WORKING WITH DATA
# Suite of packages for data manipulation and visualization
library(tidyverse)
# Working with raw sequences (.fasta)
library(seqinr)

# PHYLOGENETICS
# Phylogenetic analyses of microbiomes
library(phyloseq)
# Community ecology analyses
library(vegan)
# Phylogenetic factorization
library(phylofactor)
# Working with trees
library(ape)
# Additional ggplot functions for tree visualization
library(ggtree)

# OTHER
# Multi-panel figures
library(cowplot)

# FOR BDTT FUNCTIONS
# Using multidimensional arrays (part of BDTT functions)
library(abind)
# Working with matrices (part of BDTT functions)
library(Matrix)
# Beta-diversity turnover and nestedness
library(betapart)
```

## Downloading data
The following command downloads the data from our [GitHub](https://github.com/EDUCE-UBC/workshop_data) and since you're working in a Project, saves it in the Project directory under the `data` directory on your computer.

```{r eval=FALSE}
download.file(
  "https://raw.githubusercontent.com/EDUCE-UBC/workshop_data/master/Saanich.taxonomy",
  "data/Saanich.taxonomy")

download.file(
  "https://raw.githubusercontent.com/EDUCE-UBC/workshop_data/master/Saanich_OTU.shared",
  "data/Saanich_OTU.shared")

write.csv(
  read.csv("https://raw.githubusercontent.com/EDUCE-UBC/workshop_data/master/Saanich_Data_clean.csv"),
  "data/Saanich_Data_clean.csv", row.names=FALSE)

download.file(
  "https://raw.githubusercontent.com/EDUCE-UBC/workshop_data/master/Saanich_OTU_rep.alignment",
  "data/Saanich.OTU.rep.alignment")
```

## Loading and cleaning data 
Now that the data are downloaded on your computer, you must load them into the current R project. We also will perform a little data cleaning and formatting on these data using functions in the tidyverse. If you are unfamiliar with these packages, please see our [R tidyverse workshop](https://github.com/EDUCE-UBC/workshops_R/tree/master/intro_tidyverse).

```{r}
# Taxonomic identity of each sequence
taxonomy <- read_tsv("data/Saanich.taxonomy") %>% 
  # Separate taxa names into columns
  separate(Taxonomy,
           into=c("domain","phylum","class","order","family","genus","species"),
           sep=";") %>% 
  # Remove unused columns
  select(-Size)

# Counts of sequences in each sample
OTU <- read_tsv("data/Saanich_OTU.shared") %>% 
  # Rename sample variable
  mutate(sample=Group) %>% 
  # Remove unused columns
  select(-label, -numOtus, -Group)

# Geochemical data
metadata <- read_csv("data/Saanich_Data_clean.csv") %>% 
  # Filter to only Cruise 72
  filter(Cruise == 72) %>% 
  # Create sample names similar to OTU table
  mutate(sample=ifelse(Depth_m <100, 
                       paste("Saanich_0", Depth_m, sep=""),
                       paste("Saanich_", Depth_m, sep="")))

# Representative sequences
# Reading function from seqinr package
alignment <- read.fasta("data/Saanich.OTU.rep.alignment")
  # Change the sequences names to simple OTU numbers
  names(alignment)=taxonomy$OTU
```

## Importing custom R functions
We have written some custom R functions for use in this workshop. It is good
practice to define these functions in a separate file and then to import them
into your scripts, so that you don't duplicate the code.

Here, we download the script from the [GitHub](https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/scripts/BDTT_functions.R) and then load it into R with `source()`.

```{r, message=FALSE}
download.file(
  "https://raw.githubusercontent.com/FloMazel/BDTT/master/BDTT_functions.R",
  "scripts/BDTT_functions.R"
)
source("scripts/BDTT_functions.R")
```

# Introduction to phylogenetics
Please see the slide deck (6-32) for an introduction to and motivations for phylogenetic analysis of microbiomes.

# Building a phylogenetic tree (FastTree)
Now we can begin our analyses! The first step toward phylogenetic-based analyses is to build a tree of your sequence data in order to infer phylogenetic relatedness. We will first define homologous characters (sequence alignment) and then build the tree.

See further details in slides 33-43.

## Alignment
Sequence alignment is simply the comparison of sequences to line up (align) places where they have the same nucleotide(s) (*e.g.* ATCG). There are a number of alignment methods available in a number of softwares like [mothur](https://www.mothur.org) or [QIIME2](https://qiime2.org). Since alignment is often computationally and time intensive, we have already completed this step for the workshop data and the results are contained in the `.alignment` data file. You can learn more about this data processing in the [mothur pipeline](https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/notes/mothur_pipeline.pdf).

## Tree building
Once you have an alignment, you use these data to build a tree. There are many algorithms for tree building like parsimony or maximum likelihood (slides 36-39). For most, the basic method is to 1) define tree parameters, 2) build many trees, 3) compare these trees and select the 'best' based on the defined parameters and/or statistical tests.

### Tree constraints
Typical read lengths in microbiome studies are relatively short (150-300 bp) and thus, contain limited information to reconstruct phylogenetic trees, especially for deep (*e.g.* old) branches. To avoid biased phylogenies, we will constrain the deep branches in our tree to follow known taxonomic classifications. Here, we will constrain tree reconstruction by domain (Bacteria/Archaea) and phyla.

Please note that the choice of constraints is not always easy and can dramatically influence the results. We are only showing 1 option here and will compare constrained and unconstrained trees in order to determine if our choices were appropriate for these data. In your own data analyses, you may need to try a couple of constraint combinations in order to create the best tree.

### Define contraints
Since we will constrain these data by domain, we must remove OTUs without an assigned domain. We do  this in the taxonomy table and alignment file.

```{r}
tax.constrain <- taxonomy %>% 
  # Remove unclassified domains
  filter(domain != "unknown")

align.constrain <- alignment[tax.constrain$OTU]
```

Then, we set the domain constraints as 1 for Bacteria and 0 for Archaea in the taxonomy table.

```{r}
tax.constrain <- tax.constrain %>% 
  # Create constraint variable
  mutate(Bacteria = ifelse(domain == "Bacteria", 1, 0))
```

Next, we define the phyla constraints, giving each phylum its own column

```{r}
# List all unique phyla names
phyla.list <- taxonomy %>%
  select(phylum) %>%
  # Remove unclassified phyla
  filter(!grepl("unclassified", phylum)) 
# Keep only unique phyla in a list
phyla.list <- unique(phyla.list$phylum)

# For each phylum, create a column in the constrained taxonomy table with
# a value of 1 for the OTU being that phylum and 0 for any other phyla
for (i in phyla.list){
  tax.constrain[[as.character(i)]][tax.constrain$phylum==i]=1
  tax.constrain[[as.character(i)]][!tax.constrain$phylum==i]=0
  }

# Keep only the 0/1 constraint columns
tax.constrain2 <- tax.constrain %>% 
  select(-(OTU:species))

# View result
tax.constrain2
```

### Save constraints
For use in FastTree, the constraints must be listed in fasta format like

```
>Otu0001
100000000000000000000000000001
>Otu0002
100000000000000000000000000001
>Otu0003
100000000000000000000000000001
```

So, we can use our domain and phyla constraint columns to create this format.

```{r}
# Create empty list to hold data
sequences=list()

# For each OTU, list its 0/1 values from the constraints table
for (i in 1:nrow(tax.constrain2)){
  sequences[[i]]=tax.constrain2[i,]
  }
```

Then save as a fasta.

```{r eval=FALSE}
# Print these 0/1 lists as the "sequence" for each OTU in fasta format
write.fasta(sequences, names=tax.constrain$OTU,
            file.out="data/Saanich_tax_constrain.fasta", 
            open = "w", nbchar = 60, as.string = FALSE)
```

We should also save the modified alignment file where we've trimmed out the unclassified domain.

```{r eval=FALSE}
write.fasta(alignment, names(alignment),
            "data/Saanich_OTU_rep_mod.alignment",
            open = "w", nbchar = 60, as.string = FALSE)
```

And now we're finally ready to build a tree in FastTree!

### FastTree
Here, we will use [FastTree](http://www.microbesonline.org/fasttree/) to build trees. While FastTree is not the best software to reconstruct phylogenies (because it makes a lot of approximations), it is very, very fast. This is a huge benefit when using amplicon data from microbiomes as there are a very high number of "species" in these data. 

The FastTree function requires:

1. `-gtr`: the Generalised Time Reversible model for tree calculation
2. `-cat 20`: approximation for the rate of evolution at each nucleotide
    * Checkout the help page for more on available models
3. `-constraints`: topological constraints (the fasta file we just made)
4. `-nt`: a nucleotide alignment (the modified alignment we just made)
5. `>`: a name for the output tree

FastTree is a command line (or terminal) program. Thus, Mac and Linux users should open their default terminal programs and Windows users should open GitBash (see [setup instructions](setup/phylogenetics_setup.html) for details on terminals). 

In your terminal, navigate to wherever your R project directory for this workshop is. For example, on my computer it is in `/Users/kim/GitHub/workshops_R/phylogenetics/`. Then create a results directory to hold your trees.

```{bash}
cd /Users/kim/GitHub/workshops_R/phylogenetics/

mkdir -p results/
```

Moving into the project directory lets us shorten our final command by not including the full path to data files, as in using  `data/Saanich_tax_constrain.fasta` vs. `/Users/kim/GitHub/workshops_R/phylogenetics/data/Saanich_tax_constrain.fasta`

Then, you should call FastTree from wherever it is on your computer. Test this by first calling the help page like so. You should see the information in the output below. *Remember to change the file path to one for your computer!*

```{bash}
/Users/kim/Applications/FastTree/FastTree -help
```

Now we run FastTree on our data. Note that we can split this long command across multiple lines using `\`.

```{bash eval=FALSE}
/Users/kim/Applications/FastTree/FastTree \
-gtr -cat 20 \
-constraints data/Saanich_tax_constrain.fasta \
-nt data/Saanich_OTU_rep_mod.alignment \
> results/Saanich_FastTree_constrain
```

And we see the program running like so. It can take several minutes to complete.

```{bash eval=FALSE}
FastTree Version 2.1.10 SSE3
Alignment: data/Saanich_OTU_rep_mod.alignment
Nucleotide distances: Jukes-Cantor Joins: balanced Support: SH-like 1000
Search: Normal +NNI +SPR (2 rounds range 10) +ML-NNI opt-each=1
TopHits: 1.00*sqrtN close=default refresh=0.80
ML Model: Generalized Time-Reversible, CAT approximation with 20 rate categories
Constraints: data/Saanich_tax_constrain.fasta Weight: 100.000
Warning! Found "." character(s). These are treated as gaps

...

ML-NNI round 8: LogLk = -157162.201 NNIs 69 max delta 5.06 Time 67.83 (final)
Optimize all lengths: LogLk = -157143.499 Time 69.48 
Total time: 77.53 seconds Unique: 4368/4368 Bad splits: 25/4365 Worst unconstrained delta-LogLk 0.970
Violating constraints: 0 both bad: 0 Worst delta-LogLk due to constraints: 48.216
```
      
For the sake of comparison, we will also construct the tree WITHOUT topological constraints. In this case, just remove the `-constraints` parameter.

```{bash eval=FALSE}
/Users/kim/Applications/FastTree/FastTree \
-gtr -cat 20 \
-nt data/Saanich_OTU_rep_mod.alignment \
> results/Saanich_FastTree
```

If you are having difficulty with FastTree, you can download the tree with the following.

```{r eval=FALSE}
download.file(
  "https://raw.githubusercontent.com/EDUCE-UBC/workshops_R/master/phylogenetics/results/Saanich_FastTree",
  "results/Saanich_FastTree")

download.file(
  "https://raw.githubusercontent.com/EDUCE-UBC/workshops_R/master/phylogenetics/results/Saanich_FastTree_constrain",
  "results/Saanich_FastTree_constrain")
```

#### Exercise: FastTree
![](images/RStudio_logo.png){width=0.4in} Exercise: While the above rerunning, compare the two available nucleotide models in FastTree. Discuss the pros and cons of Jukes-Cantor (JT) versus Generalized Time-Reversible (GTR) with your table. You may find [this Wikipedia article](https://en.wikipedia.org/wiki/Models_of_DNA_evolution#Most_common_models_of_DNA_evolution) helpful.

# Visualizing trees
We will now move back into R to visualize our trees. First, load the trees we just constructed into R.

```{r, message=FALSE}
# read.tree from the ape package
tree <- read.tree('results/Saanich_FastTree')
treeC <- read.tree('results/Saanich_FastTree_constrain')
```

## phyloseq formatting
We will use a number of functions in the `phyloseq` package to plot our trees. This package requires some specific data formats, which will we create below.

First, we define parts of the phyloseq object.

```{r warning=FALSE}
# OTU table
OTU.physeq = OTU %>% 
  # set sample name as row names
  column_to_rownames(var = "sample") %>% 
  # Format to matrix
  as.matrix() %>% 
  # Format to phyloseq OTU table
  otu_table(taxa_are_rows=FALSE)

# Taxonomy
tax.physeq = taxonomy %>% 
  # set OTU # as row names
  column_to_rownames(var = "OTU") %>% 
  # Convert to matrix
  as.matrix() %>% 
  # Convert to phyloseq tax table
  tax_table()

# Metadata
metadata.physeq = metadata %>% 
  # Copy sample column
  mutate(sample2 = sample) %>% 
  # set sample names as row names
  column_to_rownames(var = "sample2") %>% 
  # Convert to phyloseq sample data
  sample_data()

# Trees
tree.physeq=phy_tree(tree)
treeC.physeq=phy_tree(treeC)
```

and then assemble them into phyloseq objects

```{r, message=FALSE}
saanich = phyloseq(OTU.physeq, tax.physeq, 
                   metadata.physeq, tree.physeq) 

saanichC = phyloseq(OTU.physeq, tax.physeq, 
                   metadata.physeq, treeC.physeq) 
```

which look the sample except that they contain different trees.

```{r}
saanich
saanichC
```

## Basic trees
Let's first just view our 2 trees.

```{r warning=FALSE, message=FALSE, fig.show='hold', out.width='50%'}
plot_tree(saanich, "treeonly") +
  # Make circular
  coord_polar(theta = "y") +
  # Plot title
  labs(title="Unconstrained tree")

plot_tree(saanichC, "treeonly") +
  # Make circular
  coord_polar(theta = "y") +
  # Plot title
  labs(title="Constrained tree")
```

While we can see that these trees are different, we can't conclude much because there are so many branches! So, let's improve our plots.

## Color by taxa
To get a better idea of which tree best represents our data, we will color by domain to see if Archaea and Bacteria group separately, as we'd expect.

```{r warning=FALSE, message=FALSE}
plot_tree(saanich, color="domain") +
  # Make circular
  coord_polar(theta = "y") +
  # Plot title
  labs(title="Unconstrained tree") +
  # Move legend to bottom
  theme(legend.position="bottom")

plot_tree(saanichC, color="domain") +
  # Make circular
  coord_polar(theta = "y") +
  # Plot title
  labs(title="Constrained tree") +
  # Move legend to bottom
  theme(legend.position="bottom")
```

#### Exercise: Color taxa trees
![](images/RStudio_logo.png){width=0.4in} Exercise: 

1. Modify the above trees to color by phylum, instead of domain. Your output should be similar to below.
2. Compare these two trees. What do you observe? Which do you think better represents these data?

```{r echo=FALSE, warning=FALSE, message=FALSE, fig.height=10}
plot_tree(saanich, color="phylum") +
  # Make circular
  coord_polar(theta = "y") +
  # Plot title
  labs(title="Unconstrained tree") +
  # Move legend to bottom
  theme(legend.position="bottom") +
  guides(col = guide_legend(ncol = 2))

plot_tree(saanichC, color="phylum") +
  # Make circular
  coord_polar(theta = "y") +
  # Plot title
  labs(title="Constrained tree") +
  # Move legend to bottom
  theme(legend.position="bottom") +
  guides(col = guide_legend(ncol = 2))
```

# Re-root the tree
We hope that you've come to the same conclusion that the constrained tree is a better fit because known taxonomic groups (domains and phyla) cluster more together closely in this tree. We can further improve this constrained tree by adding a root.

The phylogenetic tree root indicates the direction of evolution (from the root to the tip). For our tree, we will assume this to be on the branch separating Bacteria and Archaea. 

To root our tree, we first need to find this branch using the 'get most recent common ancestor function `getMRCA` from the `ape` package.

```{r}
# List all OTUs that are Archaea
archaea.list <- taxonomy %>% 
  filter(domain=="Archaea") %>% 
  select(OTU) %>% 
  as.list()

MRCAnode <- getMRCA(phy = treeC, tip = archaea.list$OTU)
```

Then, we re-root the tree on this branch

```{r}
treeC.root <- root(phy = treeC, node = MRCAnode, resolve.root = TRUE)
```

and save the corresponding tree to the disk

```{r eval=FALSE}
write.tree(treeC.root, 'results/Saanich_FastTree_constrain_root')
```

and in a new phyloseq object.

```{r message=FALSE}
treeCR.physeq <- phy_tree(treeC.root)

saanichCR <- phyloseq(OTU.physeq, tax.physeq, 
                   metadata.physeq, treeCR.physeq) 
```

We can now plot this tree and compare to the unrooted tree. It's difficult to see at this resolution but the rooted tree is (and almost always is) a better fit for these data than the unrooted version. **Thus, we will use the constrained, rooted tree in all subsequent analyses.**

```{r warning=FALSE, message=FALSE, fig.height=10}
plot_tree(saanichCR, color="phylum") +
  # Make circular
  coord_polar(theta = "y") +
  # Plot title
  labs(title="Constrained, rooted tree") +
  # Move legend to bottom
  theme(legend.position="bottom") +
  guides(col = guide_legend(ncol = 2))
```

# Classic microbiome analyses
## Beta-diversity
One common way to compare microbial communities is through beta-diversity. This is 'between sample' diversity meaning there is a value for every unique pairwise comparison of samples. Distance measures estimate how different two communities are while similarity measures estimate how similar they are. In general, distance measures are more commonly used, like those we go over below.

There are many different beta-diversity metrics, and they generally differ by the use (or exclusion) of abundance and/or phylogenetic data. To summarize

.                     | non-phylogenetic  | phylogenetic
--------------------- | ----------------- | ------------------
presence/absence only | Jaccard, Sorensen | UniFrac, Phylosor
relative abundance    | Bray-Curtis       | Weighted UniFrac

Please find further details on beta-diversity metrics on slides 44-55.

### Calculating beta-diversity
We first compute some common beta-diversity metrics. For phylogenetic metrics, we will continue to use functions in the `phyloseq` package. For non-phylogenetic metrics, we will turn to `vegan`.

```{r}
# Bray-Curtis
BC <- vegdist(otu_table(saanichCR), method = "bray")
# Jaccard
Jac  <- vegdist(otu_table(saanichCR), method = "jaccard")
# UniFrac
UF <- UniFrac(saanichCR, weighted=FALSE)
# Weighted UniFrac
wUF <- UniFrac(saanichCR, weighted=TRUE)
```

Looking at any one of these outputs, we see the pairwise comparisons between our 7 samples from Saanich Inlet.

```{r}
BC
```

### Visualizing beta-diversity
Since we have a very small data set, it is feasible to simply plot all beta-diversity values. However, most microbiome research requires 100s or even 1000s of samples. This is too many to simply plot, so we have reductionist techniques to see all the data in a simpler form. Two common examples are PCoA and nMDS, which reduce all of the pairwise comparisons down to xy(z) coordinates (slide 56).

Importantly, both PCoA and nMDS manipulate the raw beta-diversity values in order to coerce them into a plot. Moreover, beta-diversity metrics themselves are simplifications of differences across upwards of a thousand OTUs in samples. **Thus, the following plots can be informative but can also mask important differences that are present in the actual microbial communities.** 

#### Principle coordinate analysis (PCoA/PCA)
PCoA uses orthogonal transformation to convert the observed beta-diversity values into a set of values of linearly uncorrelated variables called principal components. In R, this function calculates as many axes as are need to explain 100% of the variation in the beta-diversity table, with later axes generally explaining less and less of the total. Then, you can choose to plot as many axes as you wish.

Let's compare all our metrics using PCoA.

```{r}
BC.pcoa = ordinate(saanichCR, "PCoA", distance=BC)
Jac.pcoa = ordinate(saanichCR, "PCoA", distance=Jac)
UF.pcoa = ordinate(saanichCR, "PCoA", distance=UF)
wUF.pcoa = ordinate(saanichCR, "PCoA", distance=wUF)
```

Then we can plot them using `phyloseq`'s `plot_ordination` function, coloring by sample depth so that we can directly compare points.

```{r warning=FALSE, message=FALSE, fig.show='hold', out.width='50%'}
# Set plot theme for all plots
theme_set(theme_classic())

# Plot each PCoA colored by sample
plot_ordination(saanichCR, BC.pcoa, color="sample") +
  #Make points larger
  geom_point(size = 4) +
  #Remove legend
  theme(legend.position="none") +
  # Add title
  labs(title="Bray-Curtis")

plot_ordination(saanichCR, Jac.pcoa, color="sample") +
  #Make points larger
  geom_point(size = 4) +
  #Remove legend
  theme(legend.position="none") +
  # Add title
  labs(title="Jaccard")

plot_ordination(saanichCR, UF.pcoa, color="sample") +
  #Make points larger
  geom_point(size = 4) +
  #Remove legend
  theme(legend.position="none") +
  # Add title
  labs(title="UniFrac")

plot_ordination(saanichCR, wUF.pcoa, color="sample")+
  #Make points larger
  geom_point(size = 4) +
  #Move legend
  theme(legend.position="bottom") +
  # Add title
  labs(title="weighted UniFrac")
```

We see that each axis has a percentage, which corresponding to how much of the beta-diversity variation is explained by that axis. Since we have few samples, these value are rather high, with a single plot of 2 axes explaining > 50%. However, more complex data sets may yield values as low at 10% for a single axis. 

#### Non-metric multidimensional scaling (nMDS)
Similarly, nMDS simplifies the beta-diversity data into a set of axes. In contrast, however, nMDS forces all of the data into the exact number of axes you specify. It then outputs a "stress" value that corresponds with how much the raw beta-diversity values had to be modified in order to fit the nMDS output. A lower stress value is better because it means that the nMDS plot more accurately represents the underlying data.

Let's again calculate for all our metrics.

```{r results=FALSE, warning=FALSE}
BC.nmds = ordinate(saanichCR, "NMDS", distance=BC)
Jac.nmds = ordinate(saanichCR, "NMDS", distance=Jac)
UF.nmds = ordinate(saanichCR, "NMDS", distance=UF)
```

```{r}
wUF.nmds = ordinate(saanichCR, "NMDS", distance=wUF)
```

Here, we're only printing the output for the last weighted UniFrac calculation, because all the metrics are similar. Because there are few samples, we see a 'No convergence' indicating that nMDS might not be the best representation of these data at all. 

But will continue with plots since in your own work, nMDS is a useful option.

```{r warning=FALSE, message=FALSE, fig.show='hold', out.width='50%'}
# Set plot theme for all plots
theme_set(theme_classic())

# Plot each PCoA colored by sample
plot_ordination(saanichCR, BC.nmds, color="sample") +
  #Make points larger
  geom_point(size = 4) +
  #Remove legend
  theme(legend.position="none") +
  # Add title
  labs(title="Bray-Curtis")

plot_ordination(saanichCR, Jac.nmds, color="sample") +
  #Make points larger
  geom_point(size = 4) +
  #Remove legend
  theme(legend.position="none") +
  # Add title
  labs(title="Jaccard")

plot_ordination(saanichCR, UF.nmds, color="sample") +
  #Make points larger
  geom_point(size = 4) +
  #Remove legend
  theme(legend.position="none") +
  # Add title
  labs(title="UniFrac")

plot_ordination(saanichCR, wUF.nmds, color="sample")+
  #Make points larger
  geom_point(size = 4) +
  #Move legend
  theme(legend.position="bottom") +
  # Add title
  labs(title="weighted UniFrac")
```

### Interpreting beta-diversity plots
All of the above plots are showing us a similar result. Dots at are closer together in the xy plane indicate more similar microbial communities. We see that the 10 and 200 meter samples are generally very different from the other samples but that there may be some kind of gradient shift from 100 - 200 meters (*e.g.* you can draw a straight line across depth).

In larger data sets, you will look for gradients or groupings by your variables of interest. But remember, these plots are coerced and simplified a lot. So, if you don't see a clear pattern by your variable(s) of interest, that does not mean there is no effect. To truly test for an effect, we must run a statistical test.

#### Exercise: PCoA vs. nMDS
![](images/RStudio_logo.png){width=0.4in} Exercise: Consider the two beta-diversity plotting methods above. What are the pros and cons of these methods? Which do you think best represents these data?

### Statistically testing beta-diversity
Permutational analysis of variance (PERMANOVA) is most commonly used to statistically test beta-diversity values against relevant metadata. See slides 57-59 for details.

Using `adonis` from the `vegan` package, we can build complex models from as many metadata variables as we wish using the standard R model syntax of 

`y ~ x`

Here, we will ask if overall microbial communities in Saanich Inlet differ by depth. And they do!

```{r}
adonis(BC ~ Depth_m, data=data.frame(sample_data(saanichCR)))
adonis(Jac ~ Depth_m, data=data.frame(sample_data(saanichCR)))
adonis(UF ~ Depth_m, data=data.frame(sample_data(saanichCR)))
adonis(wUF ~ Depth_m, data=data.frame(sample_data(saanichCR)))
```

Or we can test against relevant geochemical variables like concentrations of oxygen (O~2~), nitrate (NO~3~), and hydrogen sulfide (H~2~S). _Note that using `a * b` is equivalent to `a + b + a:b`._

```{r}
adonis(BC ~ O2_uM * NO3_uM * H2S_uM,
       data=data.frame(sample_data(saanichCR)))
```

#### Exercise: Randomness and variable order
![](images/RStudio_logo.png){width=0.4in} Exercise: 

1. Rerun the the last PERMANOVA several times. Do the results change? Why might this be the case and what does this mean for borderline p-value (*e.g.* P near 0.05)?

2. Next, alter the variable order in this PERMANOVA. Does this change the outcome? Why might this be the case?

# Varying phylogenetic resolution
While PERMANOVA can reveal a number of interesting results in microbiome research, it can miss complex effects and subtle variations. This is because different factors can effect the microbiome at different phylogenetic resolutions. See examples in slides 60-74.

We can delve into these effects by screening our phylogenetic in different ways.

## Screening by phylogenetic scale
In our case, phylogenetic scale is a measure of time, as in evolutionary time. We base this scale on the nucleotide sequences and resulting tree to determine approximately how long ago branches occurred.

Here, we use a custom function `getHnodes` to extract the scale (*e.g.* the scale of divergence times in substitutions/site) for all the nodes (*e.g.* branch splits) in our tree.

```{r}
Hnodes <- get_all_node_depths(treeC.root)
```

Plotting the values, we see that most of the scales are from 0 - 0.1 substitutions per site.

```{r, fig.show='hold', out.width='50%'}
hist(Hnodes, n=150)
hist(Hnodes, n=150, xlim=c(0,.5))
```

We can then define a set of discrete thresholds within the most common range of scales (0 - 0.3) and use these to extract different sets of microbial OTUs.

```{r}
#Create incremental list of values from 0 to 0.3, going up by 0.025 each time
slices <- c(seq(from=0, to=0.3, by=0.025)) 
```

The idea is to compute beta-diversity for all these slices of data. 

We first transpose our OTU table as a matrix.

```{r}
OTU.mat <- OTU %>% 
  # set sample name as row names
  column_to_rownames(var = "sample") %>% 
  # Transpose
  t() %>% 
  #Format to matrix
  as.matrix()
```

and then run the analysis for multiple beta diversity indices using our custom functions. This can take several minutes to complete.

```{r eval=FALSE}
multi.Beta<- BDTT(similarity_slices = slices,
tree = treeC.root, sampleOTUs = OTU.mat)
```

Check the multi.Beta code

```{r eval=FALSE}
class(multi.Beta)
# It is an array object i.e. a matrix with more than 2 dimensions: 
dim(multi.Beta)
# There are 4 dimensions
dimnames(multi.Beta)
# That corresponds to slices, betadiversity metric, samples and samples
```

and extract some betadiversity metrics

```{r eval=FALSE}
multi.Jac=multi.Beta[,"Jac",,]
multi.BC=multi.Beta[,"Bray",,]
#we extract two diversity metrics (Bray_curtis and Jaccard)
```

Since these functions take awhile to run, we will save the outputs for later use

```{r eval=FALSE}
saveRDS(multi.Jac, "results/multi_Jac.RDS")  
saveRDS(multi.BC, "results/multi_BC.RDS")  
```

Or you can download and load the results here.

```{r}
download.file(
  "https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/results/multi_Jac.RDS?raw=true",
  "results/multi_Jac.RDS")

multi.Jac <- readRDS("results/multi_Jac.RDS")

###

download.file(
  "https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/results/multi_BC.RDS?raw=true",
  "results/multi_BC.RDS")

multi.BC <- readRDS("results/multi_BC.RDS")
```

### Exploring array results
The `BDTT` function outputs a complex data type called an array, which is a matrix of matrices.

```{r}
class(multi.Jac)
dim(multi.Jac)
```

This means that there are 13 matrices each with 7 rows and 7 columns. Let's view just the first matrix.

```{r}
multi.Jac[1,,]
```

Here, we see the beta-diversity values at our first defined slice level. This continues in the 12 other matrices, one for each slice in the `slices` list.

## Statistical links to metadata
We can then link the multiple beta-diversity values to our metadata. In our case, we need to construct models for each threshold independently.

We first prepare the results table

```{r}
# list variables of interest
predictors <- c("O2_uM", "NO3_uM", "H2S_uM", "Depth_m")
# Create data frame of all slice, variable, metric combinations
StatsRes <- expand.grid(similarity_slices=as.character(slices),
                        predictors=predictors,
                        metric=c("Jac","BC"))
# Add blank columns to hold results
StatsRes[["F.Model"]] = StatsRes[["R2"]] = StatsRes[["Pr(>F)"]]=NA

#View first few rows of data frame
head(StatsRes)
```

and then "fill" it with our results from PERMANOVA of all models constructed in a loop. 

```{r message=FALSE}
# For each slice
for (i in as.character(slices)){
  # For each variable of interest
  for (j in predictors) {
  # Calculate PERMANOVA for Jaccard
   res <- unlist(adonis(
     formula = multi.Jac[i,,] ~
       data.frame(sample_data(saanichCR))[,j])$aov.tab[1,c(4,5,6)])
   # Add results to table
   StatsRes[(StatsRes$metric=="Jac") & 
              (StatsRes$predictors==j) & 
              (StatsRes$similarity_slices==i), 4:6] = res
   
   # Calculate PERMANOVA for Bray-Curtis
   res <- unlist(adonis(
     formula = multi.BC[i,,] ~
       data.frame(sample_data(saanichCR))[,j])$aov.tab[1,c(4,5,6)])
   # Add results to table
   StatsRes[(StatsRes$metric=="BC") &
              (StatsRes$predictors==j) &
              (StatsRes$similarity_slices==i),4:6] = res
   }
}
```

*You will see the warning 'Set of permutations < 'minperm'. Generating entire set' because the dataset is small. Please ignore.*

We can then plot the fit profiles using R^2 along our phylogenetic time scale.

```{r, message=FALSE}
ggplot(StatsRes,
       aes(y=R2, x=similarity_slices, color=predictors,
           group=predictors)) +
  geom_point(size=4) +
  geom_line(size=1) +
  facet_wrap(~metric) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

This shows us that while all variables behave roughly similar across scales for Jaccard, Bray-Curtis diversity correlates more with oxygen and depth for larger scales (*e.g.* further back in evolutionary history).

#### Exercise: Interpreting phylogenetic scale
![](images/RStudio_logo.png){width=0.4in} Exercise: Consider the above plot. What is the biological relevance to oxygen and depth behaving differently? How does this inform our questions about nutrient gradients in Saanich Inlet? 

# Phylogenetic compositional factor analysis (PhyloFactor)
Microbiome sequencing data have several ingrained and unavoidable challenges. We've addressed many of these issues (sequencing error, clustering, 'species' cutoffs) by using phylogenetic-based approaches. 

However, another major issue is the compositionality of the data, *e.g.* abundances are relative within sample. Thus, it is impossible to determine if OTU 1 truly increases in abundance or if it only appears so because other OTUs decreased. PhyloFactor addresses these data using isometric log ratios (ILR) across the tree in order to determine which branches most impact the apparent differences in abundances.

In other words, PhyloFactorization is a method for seeing how characteristics change across a phylogeny and identifying the edges of the phylogeny where these characteristics change most significantly. 

See slides 75-93 for more details and examples.

## Data formatting
PhyloFactor requires some additional cleaning of our data.

We need to subset the OTU table and taxonomy to only those tips found in the tree,

```{r}
OTU.mat.sub <- OTU.mat[row.names(OTU.mat) %in% treeC.root$tip.label,]

taxonomy.sub <- taxonomy %>% 
  filter(OTU %in% treeC.root$tip.label)
```

subset the metadata to only those samples in our microbiota data,

```{r}
metadata.sub <- metadata %>% 
  filter(sample %in% colnames(OTU.mat))
```

and create a taxonomy table not separated into columns.

```{r}
taxonomy.raw <- read_tsv("data/Saanich.taxonomy") %>% 
  # subset to only tips in the tree
  filter(OTU %in% treeC.root$tip.label) %>% 
  #rename OTU column
  mutate(OTU_ID = OTU) %>% 
  # Add rownames
  column_to_rownames(var = "OTU") %>% 
  # Remove unused columns and reorder
  select(OTU_ID, Taxonomy)
```

## Detecting microbial variables in the tree
The first approach in PhyloFactorization is to look for clades in the tree that correlate with microbial data, that is, data where you have measurements that correspond to microbial taxa. While it's rare that you have actual measurements for each species in your sample community, you can use known traits for specific taxa like genome size, metabolic capacity, etc.

For example, you may wish to know which branches in the tree have the ability to convert nitrate (NO~3~) to nitrite (NO~2~) since this is an important step in the nitrogen cycle in Saanich Inlet. You could then determine if the abundance of sequences from these branches differed across depth or some other variables of interest in the system. Thus, PhyloFactor methods help you answer questions about microbial functions or features without being constrained by named taxonomies.

Curating such data is quite timely so we will use simulated here.

### Simulated data
We can demonstrate this by simulating some random data on top of our previously calculated microbial phylogeny and adjusting the values for a few of the groups. You can imagine this simulated data as a characteristic of the microbes -- like cell diameter. 

Here, we're creating a new variable called `CellDiam`. For each tip on our tree, we draw a value from the log normal distribution using the function `rlnorm`. 

```{r}
# Set random seed for reproducibility
set.seed(1)
CellDiam <- rlnorm(length(treeC.root$tip.label))
```

Then, we re-draw values for different subsets of the tree using values that are increased or decreased by 4-fold. For our example, let's make *Arcobacter* (genus) and Actinobacteria (phylum) different from the rest.

```{r}
# Grab a Boolean vector corresponding to the Arcobacter and Actinobacteria tip labels of the Tree object
arco <- treeC.root$tip.label %in%
  taxonomy.sub[taxonomy.sub$genus == 'Arcobacter',]$OTU

actino <- treeC.root$tip.label %in%
  taxonomy.sub[taxonomy.sub$phylum == 'Actinobacteria',]$OTU

# Change those tips to have new values for CellDiam drawn from a different distribution
CellDiam[arco] <- rlnorm(sum(arco))*4
CellDiam[actino] <- rlnorm(sum(actino))/4

# Take the log of CellDiam variable for analysis
logCellDiam <- log(CellDiam)
```

### PhyloFactor using two-sample tests
Now, we can PhyloFactor the tree to discover the branches that lead to the tips with the changed values. The function `twoSampleFactor` uses two-sample tests to identify edges separating two parts of the tree that differ with respect to a data vector -- in this case, the simulated `CellDiam` values.

```{r}
pf_twoSample <- twoSampleFactor(logCellDiam, treeC.root, nfactors=5)
```

We can look at a summary of the results by calling the object.

```{r}
pf_twoSample
```

Note that it returned 5 factors, but we only changed two clades on the tree! What happened?

PhyloFactor works by sequentially partitioning the tree from the most to the least important groups with respect to your given criteria. Note that the first two factors do, in fact, correspond to large groups, roughly matching the clades we adjusted! 

```{r}
sum(actino)
sum(arco)
```

The remaining 3 factors are individual tips or very small groups that randomly obtained extreme draws from the simulated distribution.

And although statistical significance is still not well-understood for PhyloFactorization, you can see from the vector of p-values associated with these factors that there is a steep drop-off after the first two factors:

```{r}
pf_twoSample$pvals
```

We can also visualize these phylogenetic factors on the phylogeny itself using the `pf.tree` function in `PhyloFactor`, which creates a `ggtree` plot highlighting each returned factor.

```{r message=FALSE}
cellDiam.tree <- pf.tree(pf_twoSample)
```

Note that the object created by `pf.tree` has two parts: a `$legend`, which contains the colors used for each factor, and a `$ggplot`, which has the ggplot object.

Viewing these results, we can see the large (Actinobacteria) clade in purple and the smaller (*Arcobacter*) clade in blue.

```{r}
cellDiam.tree$ggplot
```

If you had more clades and/or closely sized clades, you can view the specific colors and then look up the codes [here](https://html-color.codes/).

```{r}
cellDiam.tree$legend
```

## Detecting metadata variables
Another PhyloFactorization method is to look for clades in the tree that correlate with metadata, that is, data where you have measurements that correspond to each sample. These are the most common type of collected data since you can obtain them per sample instead of trying to measure individual microbes.

Underlying this test is a **simple linear regression or ANOVA** of your variable of interest.

### PhyloFactor ranked by effect size
For example, we will find the phylogenetic factors that vary most predictably with **depth**. 

By using the built-in choice function `F`, we are asserting that we want only the factors with the largest F score to be retained (up to 5 factors). The `stop.early` parameter tells PhyloFactor to stop searching for new factors once it drops below a certain significance threshold (see the [documentation](https://github.com/reptalex/phylofactor) for more on the heuristic used and its justification).

```{r eval=FALSE}
pf_depth_F <- PhyloFactor(OTU.mat.sub, treeC.root, 
                          X = metadata.sub, 
                          frmla = Data ~ Depth_m, 
                          nfactors = 5, ncores=2, 
                          stop.early = TRUE, choice='F')
```

```{r echo=FALSE, message=FALSE}
download.file(
  "https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/results/pf_depth_F.RDS?raw=true",
  "results/pf_depth_F.RDS")

pf_depth_F <- readRDS("results/pf_depth_F.RDS")
```

Looking at the `pf_depth_F` object, we can see that it has primarily founds tips and small clades that are strongly correlated with depth.

```{r}
pf_depth_F
```

We can summarize the taxonomy of the first factor using `pf.taxa`

```{r}
pf.taxa(pf_depth_F, taxonomy.raw, factor=1)$group1
```

We see that it is a member of the Halieaceae family, an aerobic group of microbes, so it makes sense that it is associated with depth!

We can use the `$data` element of the PhyloFactor summary object to plot the isometric log-ratio (ILR)-transformed relative abundances for this factor against depth, and see that it is, in fact, nicely correlated.

```{r}
ggplot(summary(pf_depth_F, factor=1)$data, 
       aes(x = X.Depth_m, y = Data)) + 
  geom_point(size=4) + 
  geom_smooth(method='lm') +
  labs(title="Factor 1")
```

We can also check out the taxonomy of the second factor, which actually comprises 19 tips in a single monophyletic clade.

```{r}
pf.taxa(pf_depth_F, taxonomy.raw, factor=2)$group1
```

This clade of tips belongs to the Rhodobacteraceae, a photoheterotrophic lineage of Alphaproteobacteria. It would also make sense for this bacterium to be more abundant at shallower depths! Indeed, we again see a clear ILR correlation.

```{r}
ggplot(summary(pf_depth_F, factor=2)$data,
       aes(x = X.Depth_m, y = Data)) + 
  geom_point(size=4) + 
  geom_smooth(method='lm') +
  labs(title="Factor 2")
```

### PhyloFactor ranked by variance explained
The previous results were ranked according to the factors that had the strongest correlation, as measured by effect size (F). We can also rank factors according to the total proportion of variance explained, by setting `choice` equal to `'var'`.

```{r eval=FALSE}
pf_depth_var <- PhyloFactor(OTU.mat.sub, treeC.root,
                            X = metadata.sub,
                            frmla = Data ~ Depth_m,
                            nfactors = 5, ncores=2, 
                            stop.early = TRUE, choice='var')
```

```{r echo=FALSE, message=FALSE}
download.file(
  "https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/results/pf_depth_var.RDS?raw=true",
  "results/pf_depth_var.RDS")

pf_depth_var <- readRDS("results/pf_depth_var.RDS")
```

```{r}
pf_depth_var
```

Note that when optimizing for total variance explained, PhyloFactor will tend to find bigger clades, as they represent a larger overall proportion of the data. The F-scores are lower in this case than for the smaller factors, which indicate that some members of the clade are not following the same linear relationship with depth.

We can see this, for example, in the second PhyloFactor for the variance-partitioned tree. This factor represents a clade of Alphaproteobacteria, including the Rhodobacteraceae we found before.

```{r}
pf.taxa(pf_depth_var, taxonomy.raw, factor=2)$group1
```

As you can see by plotting the ILR abundances of this entire clade against depth, the correlation is not as tight across the full range.

```{r}
ggplot(summary(pf_depth_var, factor=2)$data, 
       aes(x = X.Depth_m, y = Data)) + 
  geom_point(size=4) + 
  geom_smooth(method='lm') +
  labs(title="Factor 2")
```

### PhyloFactor across multiple variables
Let's combine all that we've practiced so far to determine how different clades of the bacterial phylogeny respond to changes in different variables in our data set. 

We can use the `cowplot` package to combine different ggplot elements to simultaneously illustrate the ILR-values for individual PhyloFactors and their location on the phylogeny. For this, we'll just take the top three factors 

First, we can perform a phylofactorization of the bacterial phylogeny with respect to different variables of interest. We'll compare the bacterial groups responding to oxygen (O~2~) and nitrate (NO~3~) as these are two major electron acceptors in the water column.

Let's grab the top three factors for each, according to total variance explained.

```{r eval=FALSE}
pf_O2_var <- PhyloFactor(OTU.mat.sub, treeC.root, 
                         X = metadata.sub, 
                         frmla = Data ~ O2_uM, 
                         nfactors = 3, ncores=2, 
                         choice='var')

pf_NO3_var <- PhyloFactor(OTU.mat.sub, treeC.root, 
                          X = metadata.sub, 
                          frmla = Data ~ NO3_uM, 
                          nfactors = 3, ncores=2, 
                          choice='var')
```

```{r echo=FALSE, message=FALSE}
download.file(
  "https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/results/pf_O2_var.RDS?raw=true",
  "results/pf_O2_var.RDS")

pf_O2_var <- readRDS("results/pf_O2_var.RDS")

###

download.file(
  "https://github.com/EDUCE-UBC/workshops_R/blob/master/phylogenetics/results/pf_NO3_var.RDS?raw=true",
  "results/pf_NO3_var.RDS")

pf_NO3_var <- readRDS("results/pf_NO3_var.RDS")
```

For each PhyloFactor object, we can then use the `cowplot` library to combine separate `ggplot2` panels into a publication-ready image, showing both individual factors locations on the tree, and their response (in ILR-transformed space) to each predictor variable.

For oxygen:

```{r warning=FALSE, message=FALSE}
# Draw the PhyloFactors on the phylogeny
O2_tree <- pf.tree(pf_O2_var)
# Save tree plot
O2_tree_plot <- O2_tree$ggplot +
  labs(title="Oxygen")

# Plot each of top 3 factors
O2_plot1 <- ggplot(summary(pf_O2_var, factor=1)$data, 
                   aes(x = X.O2_uM, y = Data)) +
  # Add linear best fit
  geom_smooth(method='lm', color = O2_tree$legend$colors[1],
              se=FALSE) +
  # Add data points
  geom_point(size=4, color = O2_tree$legend$colors[1]) + 
  # Modify text labels
  labs(title = "Factor 1", x="", y="ILR abundance")

O2_plot2 <- ggplot(summary(pf_O2_var, factor=2)$data, 
                   aes(x = X.O2_uM, y = Data)) +
  geom_smooth(method='lm', color = O2_tree$legend$colors[2],
              se=FALSE) +
  geom_point(size=4, color = O2_tree$legend$colors[2]) + 
  labs(title = "Factor 2", x="", y="ILR abundance")

O2_plot3 <- ggplot(summary(pf_O2_var, factor=3)$data, 
                   aes(x = X.O2_uM, y = Data)) +
  geom_smooth(method='lm', color = O2_tree$legend$colors[3],
              se=FALSE) +
  geom_point(size=4, color = O2_tree$legend$colors[3]) + 
  labs(title = "Factor 3", x="Oxygen (uM)", y="ILR abundance")

# Combine 3 factors into 1 plot
O2_plots <- plot_grid(O2_plot1, O2_plot2, O2_plot3,
          labels = c("B","C","D"), ncol = 1, align = 'v')
```

For nitrate:

```{r warning=FALSE, message=FALSE}
# Draw the PhyloFactors on the phylogeny
NO3_tree <- pf.tree(pf_NO3_var)
# Save tree plot
NO3_tree_plot <- NO3_tree$ggplot +
  labs(title="Nitrate")

# Plot each of top 3 factors
NO3_plot1 <- ggplot(summary(pf_NO3_var, factor=1)$data, 
                   aes(x = X.NO3_uM, y = Data)) +
  geom_smooth(method='lm', color = NO3_tree$legend$colors[1],
              se=FALSE) +
  geom_point(size=4, color = NO3_tree$legend$colors[1]) + 
  labs(title = "Factor 1", x="", y="ILR abundance")

NO3_plot2 <- ggplot(summary(pf_NO3_var, factor=2)$data, 
                   aes(x = X.NO3_uM, y = Data)) +
  geom_smooth(method='lm', color = NO3_tree$legend$colors[2],
              se=FALSE) +
  geom_point(size=4, color = NO3_tree$legend$colors[2]) + 
  labs(title = "Factor 2", x="", y="ILR abundance")

NO3_plot3 <- ggplot(summary(pf_NO3_var, factor=3)$data, 
                   aes(x = X.NO3_uM, y = Data)) +
  geom_smooth(method='lm', color = NO3_tree$legend$colors[3],
              se=FALSE) +
  geom_point(size=4, color = NO3_tree$legend$colors[3]) + 
  labs(title = "Factor 3", x="Nitrate (uM)", y="ILR abundance")

# Combine 3 factors into 1 plot
NO3_plots <- plot_grid(NO3_plot1, NO3_plot2, NO3_plot3,
          labels = c("F","G","H"), ncol = 1, align = 'v')
```

Combine into 1 plot.

```{r fig.height=10}
plot_grid(O2_tree_plot, O2_plots,
          NO3_tree_plot, NO3_plots,
          labels = c("A","","E",""), ncol = 2, align = 'hv',
          rel_widths = c(1.5, 1))
```

#### Exercise: Interpreting PhyloFactor
![](images/RStudio_logo.png){width=0.4in} Exercise: Consider the results summarized in our last figure. What can you conclude? (*Hint*: Are you confident in the oxygen results given the distribution of data points along the fitted line?)

# Other visualizations using PhyloFactor
## Phylogenetic heatmaps
Heatmaps can help give us a better sense of how the data are actually distributed across samples as well as the tree. We can use the `pf.heatmap` function to draw both the tree (and highlight the relevant PhyloFactor partitions) and the (ILR-transformed) raw data for each tip:.

```{r message=FALSE}
pf.heatmap(pf_O2_var, factors=1:3, 
           column.order = order(metadata.sub$O2_uM),
           low='purple', high='yellow')
```

Now raw data are of course messy. So, heatmaps can also be used to illustrate the values predicted across the tree, using the linear models fit by PhyloFactorization above.

```{r message=FALSE}
preds <- predict(pf_O2_var)

pf.heatmap(pf_O2_var, factors=1:3, 
           Data=preds,
           column.order = order(metadata.sub$O2_uM),
           low='purple', high='yellow')
```

This more clearly shows the trends where the top 3 clades are more highly abundant when oxygen is highly abundant, which corresponds with our linear fit plots before!

***